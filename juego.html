<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Finanzas üß†</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, #70c5ce, #5dade2);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #70c5ce;
      border: 3px solid #333;
      border-radius: 12px;
      max-width: 100vw;
      height: 600px;
      width: 400px;
      touch-action: manipulation;
      position: relative;
      z-index: 0;
    }
    @media (max-width: 440px) {
      #gameCanvas {
        width: 100vw;
        height: calc(100vw * 1.5);
      }
    }
    /* Estilos para la pantalla de game over y quiz */
    .game-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      border-radius: 16px;
      padding: 2rem 3rem;
      font-weight: 900;
      text-align: center;
      width: 90%;
      max-width: 360px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      user-select: none;
      z-index: 10;
    }
    #gameOverScreen {
      color: #f87171;
      font-size: 2rem;
      box-shadow: 0 0 20px #f87171;
      display: none;
    }
    #quizModal {
      color: white;
      font-size: 1.25rem;
      box-shadow: 0 0 20px #3b82f6;
      display: none;
      z-index: 20;
    }
    .game-overlay button {
      margin-top: 1.5rem;
      background-color: #f87171;
      color: white;
      font-weight: 700;
      padding: 0.75rem 1.5rem;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 1.1rem;
      box-shadow: 0 4px 8px rgb(248 113 113 / 0.6);
    }
    #quizModal button {
      background-color: #3b82f6;
      box-shadow: 0 4px 8px rgb(59 130 246 / 0.6);
    }
    #quizModal button:hover {
      background-color: #2563eb;
    }
    .quiz-option {
        text-align: left;
        margin: 0.75rem 0;
        cursor: pointer;
    }
    .quiz-option label {
        display: block;
        padding: 0.5rem;
        background-color: rgba(255,255,255,0.1);
        border-radius: 6px;
        transition: background-color 0.2s;
    }
    .quiz-option label:hover {
        background-color: rgba(255,255,255,0.2);
    }
    .quiz-feedback {
        margin-top: 10px;
        font-size: 1rem;
        font-weight: 700;
    }
    .correct-feedback { color: #10b981; }
    .incorrect-feedback { color: #ef4444; }

    #quizTimer {
        font-size: 1.5rem;
        font-weight: bold;
        color: #f87171;
        margin-bottom: 1rem;
    }

    #countdownDisplay {
      display: none; 
      background: rgba(0, 123, 255, 0.85); 
      color: white; 
      font-size: 4rem; 
      width: 150px; 
      height: 150px; 
      border-radius: 50%; 
      padding: 0;
      line-height: 150px; /* Centrado vertical */
      text-align: center;
      box-shadow: 0 0 30px #007bff;
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gradient-to-b from-sky-400 to-blue-600 relative">

  <h1 class="text-white text-4xl font-extrabold mb-6 select-none">Flappy Finanzas üß†</h1>

  <div class="relative">
    <canvas id="gameCanvas" width="400" height="600" aria-label="Juego Flappy Bird"></canvas>

    <div id="gameOverScreen" class="game-overlay" role="alert" aria-live="assertive" aria-atomic="true" aria-hidden="true">
      <div>¬°Juego terminado!</div>
      <div class="mt-2 text-lg font-semibold text-red-300">Puntuaci√≥n: <span id="finalScore">0</span></div>
      <div id="quizResultInfo" class="text-sm font-normal mt-1 text-red-300"></div>
      <button id="restartBtn" aria-label="Reiniciar juego">Jugar de nuevo</button>
    </div>

    <div id="quizModal" class="game-overlay" style="max-width: 450px;">
        <div id="quizTimer">Tiempo restante: 15s</div>
        <h2 class="text-xl font-bold mb-3">Pregunta Financiera <span id="qNumber"></span></h2>
        <p id="qText" class="text-sm mb-4 font-normal"></p>
        <form id="quizForm" class="text-white">
            <div id="qOptionsContainer">
                </div>
            <div id="quizFeedback" class="quiz-feedback"></div>
            <button type="submit" id="submitAnswer" class="mt-4">Responder</button>
        </form>
    </div>

    <div id="countdownDisplay" class="game-overlay">
        <span id="countdownNumber">3</span>
    </div>

  </div>

  <div class="mt-6 flex flex-col items-center space-y-4">
    <button
      id="startBtn"
      class="px-6 py-3 bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-bold rounded-lg shadow-lg transition"
      aria-label="Iniciar juego"
    >
      Iniciar Juego
    </button>
    <div class="text-white text-lg font-semibold select-none" aria-live="polite" aria-atomic="true">
      Puntuaci√≥n Total: <span id="score">0</span>
    </div>
    <div class="text-white text-sm font-normal select-none" aria-live="polite" aria-atomic="true">
        Preguntas: <span id="questionsAnsweredDisplay">0</span> / <span id="totalQuestionsDisplay">10</span>
    </div>
  </div>

  <script>
    (() => {
      // --- 1. Definici√≥n de Preguntas y Constantes ---
      const questions = [
          { q: "¬øQu√© herramienta oficial del BCRA te permite revisar la situaci√≥n de deuda de un tercero?", options: ["CUIT Online", "Consulta de Deuda del BCRA", "Registro de la Propiedad"], answer: 1 },
          { q: "¬øCu√°l de estos NO es un tipo de Swap financiero mencionado en la informaci√≥n clave?", options: ["Swap de Divisas", "Swap de Tasas de Inter√©s", "Swap de Inmuebles"], answer: 2 },
          { q: "Si el historial crediticio de alguien est√° 'limpio', ¬øc√≥mo afecta el riesgo de prestarle dinero?", options: ["Aumenta el riesgo", "Disminuye el riesgo", "No tiene relaci√≥n"], answer: 1 },
          { q: "¬øCu√°l es el puntaje m√°ximo por pregunta que puedes obtener por velocidad?", options: ["50 puntos", "100 puntos", "200 puntos"], answer: 1 },
          { q: "¬øQu√© significa que el riesgo de un pr√©stamo 'aumenta'?", options: ["Es m√°s probable que te devuelvan el dinero.", "Es menos probable que te devuelvan el dinero.", "La tasa de inter√©s baja."], answer: 1 },
          { q: "¬øPara qu√© sirve el CUIT Online adem√°s de verificar el n√∫mero de CUIT?", options: ["Para ver su saldo bancario.", "Para consultar su actividad y estado fiscal.", "Para enviar un mail."], answer: 1 },
          { q: "Un Swap de Commodities se basa en el precio de materias primas como...", options: ["Acciones de tecnolog√≠a", "Petr√≥leo o ma√≠z", "Bonos del tesoro"], answer: 1 },
          { q: "¬øQu√© se recomienda firmar siempre al prestar dinero, si es posible?", options: ["Un contrato o acuerdo formal", "Una selfie de ambos", "Un recibo de supermercado"], answer: 0 },
          { q: "Si la respuesta es incorrecta en el quiz, ¬øcu√°ntos puntos se suman y qu√© pasa con el juego?", options: ["Se suman 50 puntos y contin√∫a.", "Se suman 0 puntos y termina el juego.", "Se puede reintentar la pregunta."], answer: 1 },
          { q: "El BCRA cataloga la situaci√≥n crediticia de los deudores. ¬øVerdadero o Falso?", options: ["Verdadero", "Falso"], answer: 0 },
      ];

      const QUESTION_THRESHOLD = 2; 
      const MAX_QUESTION_POINTS = 100;
      const POINT_DEDUCTION_PER_SECOND = 6.67; 
      const TIME_LIMIT_SECONDS = 15; 
      
      const INITIAL_LIFT = -10;
      const INITIAL_PIPE_SPEED = 2;
      const DIFFICULTY_INCREMENT_LIFT = -0.3; // Aumento gradual de dificultad en el salto
      const DIFFICULTY_INCREMENT_SPEED = 0.2; // Aumento gradual de dificultad en la velocidad

      // --- 2. Variables y Elementos DOM ---
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const startBtn = document.getElementById('startBtn');
      const scoreEl = document.getElementById('score');
      const gameOverScreen = document.getElementById('gameOverScreen');
      const finalScoreEl = document.getElementById('finalScore');
      const restartBtn = document.getElementById('restartBtn');
      const quizModal = document.getElementById('quizModal');
      const quizForm = document.getElementById('quizForm');
      const quizFeedback = document.getElementById('quizFeedback');
      const qOptionsContainer = document.getElementById('qOptionsContainer');
      const qText = document.getElementById('qText');
      const qNumber = document.getElementById('qNumber');
      const quizTimer = document.getElementById('quizTimer');
      const quizResultInfo = document.getElementById('quizResultInfo');
      const countdownDisplay = document.getElementById('countdownDisplay');
      const countdownNumber = document.getElementById('countdownNumber');
      const questionsAnsweredDisplay = document.getElementById('questionsAnsweredDisplay');
      document.getElementById('totalQuestionsDisplay').textContent = questions.length;

      // Variables del juego
      const bird = {
        x: 80,
        y: 300,
        width: 34,
        height: 24,
        gravity: 0.6,
        lift: INITIAL_LIFT, // Velocidad inicial de salto
        velocity: 0,
        maxVelocity: 12,
        radius: 12,
      };

      const pipeWidth = 60;
      const pipeGap = 150;
      let currentPipeSpeed = INITIAL_PIPE_SPEED; // Velocidad de tuber√≠as actual
      const pipes = [];

      let availableQuestions = [...questions]; // Copia de preguntas para selecci√≥n aleatoria
      let frameCount = 0;
      let score = 0;
      let pipesPassedSinceQuestion = 0;
      let questionsAnswered = 0;
      let questionStartTime = 0; 
      let quizTimerInterval; 
      let isQuestionActive = false;
      let gameRunning = false;
      let countdownInterval; 

      // --- Funciones de Dibujo y Creaci√≥n (omito el cuerpo para brevedad, son id√©nticas a la versi√≥n anterior) ---
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 400 * dpr;
        canvas.height = 600 * dpr;
        canvas.style.width = '400px';
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);
      }
      setupCanvas();

      // Las funciones drawPipeSegment, drawBird, drawPipes, drawGround, drawBackground, createPipe, checkCollision son id√©nticas al c√≥digo anterior. 
      // Si necesitas el c√≥digo completo para ejecutarlo, aseg√∫rate de copiarlas de la respuesta anterior.
      // -----------------------------------------------------------------------------------------------------------------------------------
      // -----------------------------------------------------------------------------------------------------------------------------------
      // Funciones de dibujo y colisi√≥n (Cuerpo omitido por ser muy largo y no cambiado, usar las del c√≥digo anterior si se necesita ejecutar)
      function drawPipeSegment(x, y, width, height, radius, isTop) {
        ctx.fillStyle = '#2E8B57';
        ctx.strokeStyle = '#1E5631';
        ctx.lineWidth = 4;
        ctx.beginPath();
        // [Cuerpo de la funci√≥n drawPipeSegment]
        if (isTop) {
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height - radius);
            ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
            ctx.lineTo(x + width - radius, y + height);
            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            ctx.lineTo(x + width, y);
            ctx.closePath();
        } else {
            ctx.moveTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x, y + height);
            ctx.closePath();
        }
        ctx.fill();
        ctx.stroke();

        ctx.strokeStyle = '#3CB371';
        ctx.lineWidth = 1.5;
        const linesCount = 6;
        const spacing = width / (linesCount + 1);
        for (let i = 1; i <= linesCount; i++) {
            const lineX = x + i * spacing;
            ctx.beginPath();
            ctx.moveTo(lineX, y + 10);
            ctx.lineTo(lineX, y + height - 10);
            ctx.stroke();
        }

        const grad = ctx.createLinearGradient(x, y, x + width, y);
        grad.addColorStop(0, 'rgba(0,0,0,0.15)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0.15)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        if (isTop) {
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height - radius);
            ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
            ctx.lineTo(x + width - radius, y + height);
            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            ctx.lineTo(x + width, y);
            ctx.closePath();
        } else {
            ctx.moveTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x, y + height);
            ctx.closePath();
        }
        ctx.fill();
      }
      function drawBird() { /* [Cuerpo de la funci√≥n drawBird] */
        const x = bird.x + bird.radius;
        const y = bird.y + bird.radius;
        const r = bird.radius;

        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.ellipse(x, y, r + 4, r + 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#FFEC8B';
        ctx.beginPath();
        ctx.ellipse(x, y, r, r - 1, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#E6C200';
        ctx.beginPath();
        ctx.ellipse(x + 3, y + 2, r / 2, r / 3, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(x + 6, y - 2, r / 4, r / 4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#FF8C00';
        ctx.beginPath();
        ctx.moveTo(x + r + 2, y);
        ctx.lineTo(x + r + 10, y - 4);
        ctx.lineTo(x + r + 10, y + 4);
        ctx.closePath();
        ctx.fill();
      }
      function drawPipes() { /* [Cuerpo de la funci√≥n drawPipes] */
        pipes.forEach((pipe) => {
          const x = pipe.x;
          const w = pipe.width;
          const radius = pipe.radius;

          const topHeight = pipe.yNorth + 400;
          drawPipeSegment(x, 0, w, topHeight, radius, true);

          const bottomY = pipe.ySouth;
          const bottomHeight = canvas.height / (window.devicePixelRatio || 1) - 80 - bottomY;
          drawPipeSegment(x, bottomY, w, bottomHeight, radius, false);
        });
      }
      function drawGround() { /* [Cuerpo de la funci√≥n drawGround] */
        const groundY = canvas.height / (window.devicePixelRatio || 1) - 80;
        const groundHeight = 80;

        ctx.fillStyle = '#DEB887';
        ctx.fillRect(0, groundY, canvas.width / (window.devicePixelRatio || 1), groundHeight);

        ctx.strokeStyle = '#C19A6B';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const y = groundY + i * 10 + 5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width / (window.devicePixelRatio || 1), y);
          ctx.stroke();
        }
      }
      function drawBackground() { /* [Cuerpo de la funci√≥n drawBackground] */
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / (window.devicePixelRatio || 1));
        gradient.addColorStop(0, '#70c5ce');
        gradient.addColorStop(1, '#5dade2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
      }
      function createPipe() { /* [Cuerpo de la funci√≥n createPipe] */
        const minPipeHeight = 50;
        const maxPipeHeight = 300;
        const pipeNorthHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1)) + minPipeHeight;
        const pipeSouthY = pipeNorthHeight + pipeGap;

        pipes.push({
          x: canvas.width / (window.devicePixelRatio || 1),
          yNorth: pipeNorthHeight - 400,
          ySouth: pipeSouthY,
          width: pipeWidth,
          passed: false,
          radius: 20,
        });
      }
      function checkCollision(pipe) { /* [Cuerpo de la funci√≥n checkCollision] */
        const bx = bird.x + bird.radius;
        const by = bird.y + bird.radius;
        const br = bird.radius;
        const px = pipe.x;
        const pw = pipe.width;
        const radius = pipe.radius;
        const pyNorth = pipe.yNorth + 400;
        const pySouth = pipe.ySouth;

        if (bx + br > px && bx - br < px + pw) {
          if (by - br < pyNorth) {
            const cx1 = px + radius;
            const cy1 = pyNorth;
            const cx2 = px + pw - radius;
            const cy2 = pyNorth;

            if (by - br < pyNorth - radius) return true;
            const dist1 = Math.hypot(bx - cx1, by - cy1);
            const dist2 = Math.hypot(bx - cx2, by - cy2);
            if (dist1 < br + radius || dist2 < br + radius) return true;
          }
        }

        if (bx + br > px && bx - br < px + pw) {
          if (by + br > pySouth) {
            const cx1 = px + radius;
            const cy1 = pySouth;
            const cx2 = px + pw - radius;
            const cy2 = pySouth;

            if (by + br > pySouth + radius) return true;
            const dist1 = Math.hypot(bx - cx1, by - cy1);
            const dist2 = Math.hypot(bx - cx2, by - cy2);
            if (dist1 < br + radius || dist2 < br + radius) return true;
          }
        }

        return false;
      }
      // -----------------------------------------------------------------------------------------------------------------------------------
      // -----------------------------------------------------------------------------------------------------------------------------------


      function resetGame() {
        bird.y = 300;
        bird.velocity = 0;
        pipes.length = 0;
        frameCount = 0;
        pipesPassedSinceQuestion = 0;
        
        // Reiniciar velocidad a valores iniciales
        currentPipeSpeed = INITIAL_PIPE_SPEED;
        bird.lift = INITIAL_LIFT;
        availableQuestions = [...questions]; // Recargar el pool de preguntas

        gameOverScreen.style.display = 'none';
        gameOverScreen.setAttribute('aria-hidden', 'true');
        quizModal.style.display = 'none';
        countdownDisplay.style.display = 'none';

        if (quizTimerInterval) clearInterval(quizTimerInterval);
        if (countdownInterval) clearInterval(countdownInterval);
      }

      // --- 3. L√≥gica del Juego Modificada ---
      function update() {
        if (!gameRunning || isQuestionActive) return;

        frameCount++;

        bird.velocity += bird.gravity;
        bird.velocity = Math.min(bird.velocity, bird.maxVelocity);
        bird.y += bird.velocity;

        const groundY = canvas.height / (window.devicePixelRatio || 1) - 80;
        if (bird.y + bird.height > groundY) {
          bird.y = groundY - bird.height;
          bird.velocity = 0;
        }

        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }

        if (frameCount % 100 === 0) {
          createPipe();
        }

        pipes.forEach((pipe, index) => {
          pipe.x -= currentPipeSpeed; // Uso de la velocidad actual

          if (!pipe.passed && pipe.x + pipe.width < bird.x) {
            pipe.passed = true;
            score++;
            pipesPassedSinceQuestion++;
            scoreEl.textContent = score;

            // L√≥gica para lanzar la pregunta cada QUESTION_THRESHOLD
            if (pipesPassedSinceQuestion >= QUESTION_THRESHOLD && availableQuestions.length > 0 && !isQuestionActive) {
                isQuestionActive = true;
                showQuestion(); // Llamar sin √≠ndice, la pregunta es aleatoria
                return; 
            }
          }

          if (pipe.x + pipe.width < 0) {
            pipes.splice(index, 1);
          }

          if (checkCollision(pipe)) {
            endGame("collision");
          }
        });
      }

      function draw() {
        drawBackground();
        drawPipes();
        drawGround();
        drawBird();
      }

      function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }
      
      // Funci√≥n para incrementar dificultad
      function increaseDifficulty() {
          currentPipeSpeed += DIFFICULTY_INCREMENT_SPEED;
          bird.lift += DIFFICULTY_INCREMENT_LIFT; // lift es negativo, por lo que -= le dar√≠a menos salto (m√°s dif√≠cil). Usamos +=
      }

      function continueGame(pointsWon) {
          // Si gan√≥ puntos, significa que respondi√≥ correctamente, por lo tanto aumentamos la dificultad
          if (pointsWon > 0) {
              increaseDifficulty();
          }
          
          pipesPassedSinceQuestion = 0; 
          quizModal.style.display = 'none';
          quizModal.setAttribute('aria-hidden', 'true');
          
          if (availableQuestions.length === 0) {
              endGame("win", `¬°Completaste las ${questions.length} preguntas! ¬°Eres un experto!`);
          } else {
              startCountdown(); // Iniciar conteo de 3 segundos
          }
      }

      function startCountdown() {
          let count = 3;
          countdownNumber.textContent = count;
          countdownDisplay.style.display = 'flex';
          
          countdownInterval = setInterval(() => {
              count--;
              if (count > 0) {
                  countdownNumber.textContent = count;
              } else {
                  clearInterval(countdownInterval);
                  countdownDisplay.style.display = 'none';
                  isQuestionActive = false;
                  gameLoop(); // Reanudar el juego
              }
          }, 1000);
      }

      function startGame() {
        score = 0;
        questionsAnswered = 0;
        resetGame();
        scoreEl.textContent = score;
        questionsAnsweredDisplay.textContent = questionsAnswered;

        gameRunning = true;
        startBtn.disabled = true;
        startBtn.classList.add('opacity-50', 'cursor-not-allowed');
        gameLoop();
      }

      function endGame(reason, resultInfo = "") {
        gameRunning = false;
        isQuestionActive = false;
        
        finalScoreEl.textContent = score;
        quizResultInfo.textContent = resultInfo || (reason === "collision" ? "El p√°jaro choc√≥ con una tuber√≠a o el suelo." : "");
        
        gameOverScreen.style.display = 'block';
        gameOverScreen.setAttribute('aria-hidden', 'false');
        quizModal.style.display = 'none'; 
        countdownDisplay.style.display = 'none';

        startBtn.disabled = false;
        startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }

      function flap() {
        if (!gameRunning || isQuestionActive) return;
        bird.velocity = bird.lift;
      }

      // --- 4. L√≥gica del Quiz ---

      function handleQuizTimeout() {
          // Tratar el tiempo agotado como respuesta incorrecta
          quizFeedback.textContent = "‚åõ ¬°Tiempo agotado! 0 puntos.";
          quizFeedback.classList.remove('correct-feedback');
          quizFeedback.classList.add('incorrect-feedback');
          
          setTimeout(() => {
              continueGame(0);
          }, 1500);
      }


      function showQuestion() {
          // Seleccionar una pregunta aleatoria de las disponibles
          const randomIndex = Math.floor(Math.random() * availableQuestions.length);
          const qData = availableQuestions[randomIndex];

          // Guardar el √≠ndice original de la pregunta para poder removerla
          qData.originalIndex = randomIndex;
          
          qNumber.textContent = questionsAnswered + 1;
          qText.textContent = qData.q;
          quizFeedback.textContent = '';
          qOptionsContainer.innerHTML = '';
          quizForm.reset();

          qData.options.forEach((option, i) => {
              const div = document.createElement('div');
              div.classList.add('quiz-option');
              div.innerHTML = `
                  <label>
                      <input type="radio" name="answer" value="${i}" class="mr-2" required>
                      ${option}
                  </label>
              `;
              qOptionsContainer.appendChild(div);
          });
          
          questionStartTime = Date.now();
          quizModal.style.display = 'block';
          quizModal.setAttribute('aria-hidden', 'false');
          startQuizTimer(); 
      }

      function startQuizTimer() {
          let time = TIME_LIMIT_SECONDS;
          quizTimer.textContent = `Tiempo restante: ${time}s`;
          
          quizTimerInterval = setInterval(() => {
              time--;
              quizTimer.textContent = `Tiempo restante: ${time}s`;
              
              if (time <= 0) {
                  clearInterval(quizTimerInterval);
                  handleQuizTimeout();
              }
          }, 1000);
      }


      function checkAnswer(event) {
          event.preventDefault();

          if (quizTimerInterval) clearInterval(quizTimerInterval);

          const selectedOption = quizForm.querySelector('input[name="answer"]:checked');
          if (!selectedOption) {
              quizFeedback.textContent = "¬°Debes seleccionar una respuesta!";
              quizFeedback.classList.add('incorrect-feedback');
              startQuizTimer();
              return;
          }

          const selectedIndex = parseInt(selectedOption.value);
          // Obtener la pregunta actual (la √∫ltima que se mostr√≥)
          const currentQuestion = availableQuestions.find(q => q.q === qText.textContent); 

          let pointsWon = 0;
          
          if (selectedIndex === currentQuestion.answer) {
              const timeElapsedSeconds = (Date.now() - questionStartTime) / 1000;
              pointsWon = Math.max(0, MAX_QUESTION_POINTS - Math.floor(timeElapsedSeconds * POINT_DEDUCTION_PER_SECOND));
              
              score += pointsWon;
              questionsAnswered++;
              scoreEl.textContent = score;
              questionsAnsweredDisplay.textContent = questionsAnswered;

              // Eliminar la pregunta respondida correctamente del pool de disponibles
              availableQuestions.splice(currentQuestion.originalIndex, 1);
              
              quizFeedback.textContent = `‚úÖ ¬°Correcto! Ganaste ${pointsWon} puntos.`;
              quizFeedback.classList.remove('incorrect-feedback');
              quizFeedback.classList.add('correct-feedback');

              setTimeout(() => {
                  continueGame(pointsWon);
              }, 1500);
          } 
          else {
              quizFeedback.textContent = "‚ùå Incorrecto. 0 puntos por la pregunta. ¬°El juego contin√∫a!";
              quizFeedback.classList.remove('correct-feedback');
              quizFeedback.classList.add('incorrect-feedback');
              
              // No se incrementa questionsAnswered ni se elimina la pregunta, para que pueda salir de nuevo.
              // Solo se contin√∫a el juego.
              setTimeout(() => {
                  continueGame(0);
              }, 1500);
          }
      }
      
      // --- 5. Eventos ---
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);
      quizForm.addEventListener('submit', checkAnswer);

      canvas.addEventListener('mousedown', flap);
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        flap();
      }, { passive: false });

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (!gameRunning && !isQuestionActive) {
            startGame();
          } else {
            flap();
          }
        }
      });

      // Mensaje inicial en canvas
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Presiona "Iniciar Juego" o barra espaciadora para comenzar', canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1));
    })();
  </script>
</body>
</html>
